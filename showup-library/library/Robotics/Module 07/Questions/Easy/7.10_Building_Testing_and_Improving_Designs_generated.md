# Easy Multiple-Choice Question Content for Building, Testing, and Improving Designs

## Learning Objectives
- Build a robot by using a step-by-step plan
- Test your robot to find what works and what needs fixing
- Make your robot better based on test results

## Implementation Techniques

### Build Planning and Preparation
- Gather all materials and components before starting
- Check that no parts are missing
- Make a list of needed tools (screwdrivers, wire strippers)
- Set up workspace with good lighting and enough room
- Use small containers to organize tiny parts like screws
- Create a step-by-step build sequence
- Main structure/chassis usually comes before motors
- Electronics typically go in last to avoid damage

### Assembly Procedures
- Follow your build sequence without rushing
- Make sure connections are secure but not overtightened
- Be careful with wiring
- Color-code wires when possible (red for power, black for ground)
- Use labels or diagrams to track connections
- Double-check electrical connections before powering up
- Take photos during the build process

### Virtual vs. Physical Implementation
- Virtual robots let you test ideas quickly without spending money
- Programs like Tinkercad Circuits can be used for virtual testing
- Physical robots provide hands-on experience with real-world challenges
- NASA uses both approaches for Mars rovers
- Test initial ideas in simulation, then build physically

## Systematic Testing Methods

### Designing Test Protocols
- Identify exactly what you want to test (speed, accuracy, battery life)
- Create specific test cases with clear steps
- Good test protocols should be repeatable, measurable, and fair
- Include details about the testing environment

### Data Collection and Documentation
- Create tables or charts to record test results
- Record observations that might explain results
- Take photos or videos during testing
- Keep a testing journal with dates, results, and improvement ideas

### Performance Metrics and Benchmarks
- Minimum requirements: bare minimum for functionality
- Target goals: performance level for intended purpose
- Stretch goals: exceptional performance standards

## Problem Analysis and Troubleshooting

### Identifying Failure Points
- Break down robot into systems: mechanical, electrical, programming
- Test each system separately when possible
- Check if mechanical parts move freely
- Verify electrical connections are secure
- Try running simplified versions of code
- Use the "half-split" method to narrow down problems
- Check obvious things first (loose wires, low battery)

### Root Cause Analysis
- Look beyond the symptom to find why the problem happened
- The "Five Whys" method helps find fundamental causes

### Systematic Debugging Approaches
- Work methodically rather than making random guesses
- Isolate moving parts and test them individually
- Check for loose connections
- Test power sources first
- Document everything you try and the results

## Design Iteration Principles

### Making Targeted Improvements
- Change specific parts based on test results
- Make one change at a time when possible
- Keep original design goals in mind

### Prioritizing Changes
- Use impact/effort matrix with four sections:
  1. High impact, low effort (Quick wins)
  2. High impact, high effort (Major projects)
  3. Low impact, low effort (Easy fixes)
  4. Low impact, high effort (Not worth it)
- Fix critical flaws before making optional enhancements

### Documenting Design Evolution
- Create a design log with version numbers
- Record specific changes made in each version
- Document why changes were made
- Include photos or diagrams of each version

## Verification and Validation

### Confirming Requirements Are Met
- Review original design requirements
- Create specific tests for each requirement
- Create a verification table showing pass/fail status

### Validating Real-World Performance
- Test robot in environments similar to where it will be used
- Collect feedback from potential users

### Final Design Documentation
- Include design overview
- List detailed specifications
- Provide assembly instructions
- Include well-commented code
- Document performance data
- Summarize design history
- Note known limitations
- Suggest future improvements