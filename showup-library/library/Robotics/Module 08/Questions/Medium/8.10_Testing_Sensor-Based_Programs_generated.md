# MEDIUM-Level Content for Multiple-Choice Questions

## Testing Sensor-Based Programs

### Why Testing Sensors Matters
- Sensors interact with the physical world, which is unpredictable and variable
- The same robot might work in one environment but fail in another (e.g., well-lit classroom vs. dimly lit hallway)
- Testing helps identify how robots will behave across different situations and environments

### Systematic Testing Approach
- Test-driven development for sensors follows a progression of complexity:
  - Step 1: Testing individual sensor inputs to verify correct readings
  - Step 2: Testing simple conditional responses (one sensor triggering one action)
  - Step 3: Testing complex interactions between multiple sensors
  - Step 4: Testing edge cases (extreme values, rapid changes in readings)
  - Step 5: Testing across various environmental conditions

### Testing Process Considerations
- How sensors respond to different stimuli (e.g., light sensor readings with flashlight vs. covered)
- How conditional programming affects robot behavior
- How multiple sensors interact to create complex behaviors
- How environmental factors impact sensor reliability

### Debugging Sensor Programs
- Debugging approaches that reveal sensor processing:
  - Adding print/log statements to display sensor values during operation
  - Using visualization tools to display sensor readings graphically
  - Simplifying complex programs to isolate specific problems
  - Checking sensor calibration and physical mounting

### Common Sensor Issues
- Problems with physical mounting (e.g., distance sensor tilted downward detecting floor)
- Environmental interference (e.g., dust on light sensors)
- Code logic issues when handling multiple sensor inputs
- Calibration problems affecting sensor reading accuracy

### Sensor-Based Autonomy
- How sensors enable adaptation to unexpected situations
- Why sensor-based navigation differs from pre-programmed paths
- How sensors transform robots from "confused wanderers" to "smart navigators"