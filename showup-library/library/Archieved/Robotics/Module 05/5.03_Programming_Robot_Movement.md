# 5.3
# **Programming Robot Movement**

## Learning Objectives

By the end of this session, you'll be able to:
- List the basic robot movement commands
- Create simple paths by putting commands in order
- Test and fix issues in your robot movement programs
### **Lesson Podcast Discussion: Connecting Programming to Physical Robot Actions**

This podcast explores how abstract code sequences translate into real-world robot behaviors and why understanding this connection is crucial for effective robotics programming.

## **Understanding Basic Movement Commands**

Before we can create complex robot behaviors, we need to understand the fundamental movement commands that control our robots. Most educational robots support a standard set of basic movement instructions that serve as building blocks for more complex behaviors.

### **Core Movement Commands**

The most common movement commands include:

- **forward(distance)**: Moves the robot forward by the specified distance
- **backward(distance)**: Moves the robot backward by the specified distance  
- **left(degrees)**: Rotates the robot left by the specified number of degrees
- **right(degrees)**: Rotates the robot right by the specified number of degrees
- **wait(seconds)**: Pauses the robot's execution for the specified number of seconds

These commands may look slightly different depending on your programming environment, but the concepts remain the same. For example, in some environments you might see `move(100)` instead of `forward(100)`, or `turn(-90)` instead of `left(90)`.

Think of these commands like giving directions to a friend: "Walk forward 10 steps, turn right, walk forward 5 steps." Just like your friend needs clear instructions to reach a destination, robots need precise movement commands to complete tasks.

## **Creating Movement Patterns**

Movement patterns are sequences of commands that create specific paths or behaviors. By combining basic movement commands in the right order, we can create precise movement patterns for our robots.

### **Simple Patterns**

Let's look at some common movement patterns:

**Line pattern:**

```
forward(100)
wait(1)
backward(100)
```

**Square pattern:**

```
forward(100)
left(90)
forward(100)
left(90)
forward(100)
left(90)
forward(100)
left(90)
```

**Triangle pattern:**

```
forward(100)
left(120)
forward(100)
left(120)
forward(100)
left(120)
```

Notice how these patterns use repetition of simple commands to create recognizable shapes. The key is understanding how the sequence affects the robot's path.

### **Real-World Movement Applications**

Think about how robots move in different environments. A robot vacuum needs to move differently on carpet versus tile floors. On carpet, it might need to move more slowly and use more power. On tile, it can move faster but needs to be careful not to slip. The same basic movement commands are used, but how they're combined changes based on the surface.

Similarly, a school security robot might patrol hallways using these movement patterns:

```
# Patrol a hallway
forward(500)  # Move down the hall
wait(5)       # Pause to scan the area
backward(500) # Return to starting point
```

This simple pattern helps the robot monitor a specific area before returning to its starting position.

In the real world, delivery robots in hospitals use similar movement patterns to navigate hallways and deliver medications to different departments. These robots might follow a pattern like:

```
# Hospital delivery route
forward(200)         # Move down main corridor
right(90)            # Turn toward pediatrics wing
forward(150)         # Move to medication drop-off point
wait(30)             # Wait for staff to retrieve medication
backward(150)        # Return to main corridor
left(90)             # Face original direction
```

## **Combining Multiple Movements**

Now that we understand basic movement patterns, let's explore how to create more complex robot behaviors by combining different types of movements. This allows us to build sophisticated robot actions that can solve real-world problems.

### **Creating Functions for Reusable Movements**

Rather than repeating the same sequence of commands multiple times, we can define functions that perform specific movement patterns:

```
function square(size) {
  for (let i = 0; i < 4; i++) {
    forward(size)
    left(90)
  }
}

function zigzag(length, height, count) {
  for (let i = 0; i < count; i++) {
    forward(length)
    right(90)
    forward(height)
    left(90)
  }
}
```

By creating these reusable functions, we can simplify our main program:

```
square(100)
forward(50)
zigzag(50, 25, 3)
```

This approach makes our code more readable and easier to modify.

Think of these functions like recipes in a cookbook. Instead of writing out all the steps each time you want to make chocolate chip cookies, you just follow the "chocolate chip cookie recipe." Similarly, functions let us package movement patterns for easy reuse.

### **Complex Movement Examples**

Let's look at how we can combine basic movements to create more interesting robot behaviors:

**Line-following robot:**
```
while (sensor.detectsLine()) {
  if (sensor.lineIsLeft()) {
    left(10)  // Small correction to the left
  } else if (sensor.lineIsRight()) {
    right(10) // Small correction to the right
  } else {
    forward(20) // Move forward when centered on the line
  }
}
```

**Obstacle-avoiding robot:**
```
function avoidObstacle() {
  backward(20)    // Back up a bit
  left(90)        // Turn left
  forward(50)     // Move forward to go around obstacle
  right(90)       // Turn right
  forward(50)     // Move forward past the obstacle
  right(90)       // Turn right again
  forward(50)     // Return to original path
  left(90)        // Face original direction
}

// Main program
while (true) {
  if (sensor.detectsObstacle()) {
    avoidObstacle()
  } else {
    forward(20)
  }
}
```

These examples show how the same basic movement commands can be combined in different ways to create robots that can follow lines or navigate around obstacles.

According to a 2022 educational robotics study, students who understand how to combine movement commands effectively solve robotics challenges 40% faster than those who only know individual commands. This highlights the importance of learning not just the commands, but how to combine them creatively.

---stopandreflect---
**CHECKPOINT:** Think about the relationship between the code you write and the physical movement of the robot. How does understanding this connection help you write better movement programs?
---stopandreflectEND---

## **Testing and Fixing Movement Programs**

Even well-planned robot movement programs often don't work perfectly the first time. Learning to identify and fix issues in your movement programs is an essential robotics programming skill.

### **Common Movement Errors**

Some typical errors in movement programs include:

1. **Incorrect distances or angles**: The robot doesn't move the intended distance or turn the correct angle
2. **Sequence errors**: Commands are executed in the wrong order
3. **Missing commands**: A required movement is omitted from the sequence
4. **Timing issues**: The robot executes commands too quickly or with improper delays

### **Debugging Process**

When your robot doesn't move as expected, follow this debugging process:

1. **Observe**: Watch the robot's actual behavior compared to what you expected
2. **Identify**: Determine where the deviation from expected behavior occurs
3. **Hypothesize**: Formulate a theory about what's causing the problem
4. **Test**: Make a single change to your program and observe the result
5. **Repeat**: Continue the process until the robot behaves as expected

For example, if your robot should make a square but instead makes an odd shape, you might:
- Check your turn angles (are they exactly 90 degrees?)
- Verify movement distances (are all sides the same length?)
- Confirm the sequence has the correct number of movements (four sides require four forward commands and four turns)

This debugging process is similar to how a doctor diagnoses an illness. The doctor observes symptoms, identifies abnormalities, forms a hypothesis about the cause, tests with treatments, and repeats until the patient improves. In robotics, your "patient" is the robot's movement program!

### **Debugging Example: School Robot Gone Wrong**

Imagine programming a robot to deliver items between classrooms. Your program should make the robot:
1. Leave the office
2. Turn right down the hallway
3. Go to the third classroom
4. Turn left into the classroom
5. Deliver the item
6. Return to the office

But instead, your robot keeps going past the third classroom! Here's how you might debug:

1. **Observe**: The robot passes the third classroom without stopping
2. **Identify**: The robot isn't counting classrooms correctly
3. **Hypothesize**: Maybe the distance between classrooms varies
4. **Test**: Change the program to use door sensors instead of fixed distances
5. **Repeat**: Test the new program and adjust as needed

This real-world example shows how the same debugging process applies to more complex robot tasks.

In a middle school robotics competition, one team's robot was supposed to navigate a maze but kept hitting walls. By carefully observing where the robot went wrong and testing different turning angles, they discovered their robot's wheels were slightly different sizes, causing turns to be inconsistent. They adjusted their turn commands to compensate and successfully completed the maze!

---checkyourunderstanding---
If a robot needs to travel from point A to point B, then return to point A following a different path, what sequence elements are essential in your program?

A. The robot must first determine its current location before starting movement

B. The program must include at least one wait command between movements

C. The sequence must use the same movement distances going and returning

D. The program must include different command sequences for the outbound and return journeys
---answer---
The correct answer is D. The program must include different command sequences for the outbound and return journeys. Since the robot needs to follow a different path on the return journey, the program must contain distinct command sequences for each part of the journey. If you chose a different answer, remember that robots follow commands literally - to take different paths, you must provide different instructions for each path.
---answerEND---
---checkyourunderstandingEND---

---stopandreflect---
**CHECKPOINT:** Consider a time when your robot movement program didn't work as expected. What specific debugging steps did you take to identify and fix the problem? What did this experience teach you about the importance of testing in robotics programming?
---stopandreflectEND---


---keytakeaways---
## Key Takeaways
- Robot movement programs use basic commands (forward, backward, left, right, wait) that can be combined to create simple shapes like squares and triangles or more complex behaviors.
- Creating reusable functions for movement patterns makes your code easier to read, modify, and reuse - just like following a recipe instead of writing out all the steps each time.
- When your robot doesn't move correctly, follow a debugging process: observe what's happening, identify where it goes wrong, make a guess about the cause, test a change, and repeat until it works.
---keytakeawaysEND---