# 6.9
## Using Functions for Reusable Movements

## Learning Objectives

By the end of this session, you'll be able to:
- Create simple functions to make robot moves you can reuse
- Use tips to make your robot move better and save power
- Find and fix common problems in your robot's movement

To make your code more organized and reusable, define functions for common movement patterns:

```
function square(sideLength) {
  for (let i = 0; i < 4; i++) {
    moveForward(sideLength);
    turnLeft(90);
  }
}

// Now you can create squares of any size
square(10);  // Small square
square(50);  // Large square
```

This approach makes your code easier to read and maintain.

### **Optimizing Movement Programs**

As you become more experienced with programming robot movements, you'll want to optimize your programs for:

1. **Efficiency**: Using the fewest commands to accomplish a task
2. **Battery usage**: Creating movement patterns that conserve energy
3. **Time**: Completing tasks as quickly as possible while maintaining accuracy
4. **Smoothness**: Creating natural-looking movements without jerky stops and starts

For example, instead of having a robot make four separate 90-degree turns to face the opposite direction, you could optimize by using a single 180-degree turn, saving time and battery power.

---stopandreflect---
## Stop and reflect
**CHECKPOINT:** Think about a time when you gave someone directions to a location. How is programming robot movement similar to or different from giving verbal directions to a person? What additional considerations do you need to make when the recipient of instructions is a robot rather than a human?
---stopandreflectEND---

## **Testing and Fixing Movement Programs**

Even with careful planning, movement programs rarely work perfectly on the first try. Testing and debugging are essential skills for successful robot programming.

### **Common Movement Problems**

Several issues commonly arise with movement programs:

1. **Alignment errors**: Small turning errors that compound over time
2. **Surface variations**: Different surfaces affect movement differently
3. **Battery levels**: Lower battery can mean slower movements
4. **Hardware differences**: Two seemingly identical robots may move differently

To address these issues, you need a systematic approach to testing and debugging.

### **Debugging Strategies**

When your robot doesn't move as expected:

1. Test one command at a time to identify where the problem occurs
2. Use visual markers to track expected positions
3. Add pauses between commands to observe each step
4. Adjust parameters incrementally rather than making large changes
5. Consider environmental factors that might be affecting movement

Remember that physical robots have mechanical limitations and variability that virtual simulations don't always capture accurately.




---keytakeaways---
## Key Takeaways
- Functions help you create reusable movement patterns for your robot, making your code more organized and easier to use again.
- Optimizing your robot's movements for efficiency, battery usage, speed, and smoothness helps it perform better.
- When your robot doesn't move correctly, test one command at a time and make small adjustments to fix problems like alignment errors or surface variations.
---keytakeawaysEND---