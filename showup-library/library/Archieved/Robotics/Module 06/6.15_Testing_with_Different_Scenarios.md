# 6.15
## **Testing with Different Scenarios**

## Learning Objectives

By the end of this session, you'll be able to:
- Create a test plan with clear steps
- Find bugs by testing edge cases
- Tell the key parts of good code testing

Thorough testing involves checking how your program behaves under different conditions.

### **Test Case Design**

Good test cases should:
- Cover both typical and edge cases
- Include valid and invalid inputs
- Test boundary conditions (like minimum and maximum values)
- Check all possible paths through your code

When designing tests for your robot program, think about all the different situations your robot might encounter. For example, if your robot is programmed to follow a line, you should test it on straight lines, curved lines, and intersections. You should also test what happens if there's no line at all, or if the line has a gap in it. By testing these different scenarios, you can make sure your program works in all situations, not just the easy ones.

### **Creating a Test Plan**

A systematic test plan includes:
1. A list of specific scenarios to test
2. The expected outcome for each scenario
3. A way to verify the actual results
4. Documentation of any discrepancies

A test plan is like a checklist for your program. For a robot maze-solving program, your test plan might include tests like: "Robot reaches the end of a straight path," "Robot correctly turns at a T-junction," and "Robot doesn't crash into walls." For each test, write down what should happen and then check if your program actually does it. Keep track of any tests that fail so you know what to fix.

### **Automated vs. Manual Testing**

- **Manual testing**: You personally run the program and observe its behavior
- **Automated testing**: Write additional code that automatically tests your program
- Both approaches are valuable - manual testing helps you understand the user experience, while automated testing can quickly check many different scenarios

There are two main ways to test your programs. Manual testing is when you run your program yourself and watch what happens. This is like playing a video game to see if it's fun. Automated testing is when you write another program to test your main program. This is like having a robot play the video game for you, trying every possible move to make sure nothing breaks. Both types of testing are important - manual testing helps you see how your program feels to use, while automated testing can check many more situations much faster.

---stopandreflect---
## Stop and reflect

**CHECKPOINT:** Think about a time when you encountered a problem in a program or game. How did you approach solving it? Consider how a systematic debugging process might have made finding the solution easier.
---stopandreflectEND---

## **Improving Your Programs**

Debugging isn't just about fixing errorsâ€”it's also an opportunity to improve your code.

### **Code Refactoring**

After fixing bugs, consider:
- Simplifying complex sections
- Breaking long functions into smaller ones
- Improving variable names for clarity
- Adding comments to explain tricky parts

Refactoring is like cleaning and organizing your room. Even if everything works, it can still be messy and hard to find things. When you refactor code, you make it cleaner and easier to understand without changing what it does. For example, if you have a long section of code that makes your robot dance, you might break it into smaller parts like "spinMove()", "jumpMove()", and "waveMove()". This makes your code easier to read and easier to fix if something goes wrong later.

### **Defensive Programming**

Prevent future bugs by:
- Adding error checking for unusual situations
- Validating input values before using them
- Creating clear error messages
- Using consistent formatting and styles

Defensive programming is like wearing a helmet when you ride a bike - it helps protect you from problems before they happen. For example, if your program asks the user to enter a number between 1 and 10, you should check that they actually entered a number in that range. If they enter 0 or 11 or "banana," your program should display a helpful message instead of crashing. By planning for things that might go wrong, you make your programs more reliable and user-friendly.

---checkyourunderstanding---
What is the first step in debugging a program that isn't working?

A. Start over with a new program

B. Ask someone else to fix it

C. Identify exactly what's happening versus what should happen

D. Add more code to fix the problem
---answer---
The correct answer is C. Identify exactly what's happening versus what should happen. Effective debugging starts with clearly understanding the problem by identifying the difference between the current behavior and the expected behavior. If you chose A, starting over is rarely the most efficient approach. If you chose B, while collaboration is valuable, you should first try to understand the problem yourself. If you chose D, adding more code without understanding the issue often makes the problem worse.
---answerEND---
---checkyourunderstandingEND---




---keytakeaways---
## Key Takeaways
- Good testing involves checking both normal cases and edge cases, with a clear test plan that lists what you expect to happen in each scenario.
- Both manual testing (where you run the program yourself) and automated testing (using code to test your program) are important for finding different types of problems.
- Improving your code through refactoring (making it cleaner) and defensive programming (preparing for potential problems) helps prevent future bugs.
---keytakeawaysEND---